// Package oauth1 implements an OAuth 1.0a client per RFC 5849.
package oauth1

import (
	"errors"
	"io/ioutil"
	"net/http"
	"net/url"
)

// Token contains an end-user's tokens.
// This is the data you must store to persist authentication.
//
// Example usage:
//	// Configure a new Transport.
//	t := oauth1.Transport{
//		Key:                     os.Getenv("FITBIT_CLIENT_KEY"),
//		Secret:                  os.Getenv("FITBIT_CLIENT_SECRET"),
//		CallbackURI:             os.Getenv("FITBIT_CALLBACK_URI"),
//		TemporaryCredentialsURI: "https://api.fitbit.com/oauth/request_token",
//		AuthorizationURI:        "https://www.fitbit.com/oauth/authorize",
//		TokenRequestURI:         "https://api.fitbit.com/oauth/access_token",
//	}
//
//	// Request a set of temporary credentials.
//	auth, err := t.RequestTemporaryCredentials()
//	if err != nil {
//		return
//	}
//
//	// Most flows would redirect the user to the auth URI.
//	fmt.Println("Enter the following URI in your browser.")
//	fmt.Println(auth)
//
//	var verifier string
//	fmt.Printf("Paste the verifier here: ")
//	fmt.Scanf("%s", &verifier)
//
//	// Exchange temporary credentials for proper request token.
//	form, err := t.RequestToken(verifier)
//	if err != nil {
//		return
//	}
//
//	fmt.Println(t.Token.Key)
//	fmt.Println(t.Token.Secret)
//
//	// Some providers return additional data with the token.
//	fmt.Println(form.Get("encoded_user_id"))
//
//	// Perform authenticated requests.
//	client := t.Client()
//	response, err := client.Get("https://api.fitbit.com/1/user/-/profile.json")
//	if err != nil {
//		fmt.Println(err)
//		return
//	}
//
//	defer response.Body.Close()
//
//	activities, err := ioutil.ReadAll(response.Body)
//	if err != nil {
//		return
//	}
//
//	fmt.Println(string(activities))
//
type Token struct {
	Key    string
	Secret string
}

// Transport implements http.RoundTripper. When configured, it can be
// used to make authenticated HTTP requests.
type Transport struct {
	// Key is the identifier string generated by the API for the handshake.
	// The key can be treated as a username.
	Key string

	// Secret is the unique token generated for signing requests.
	// The secret must be kept private.
	Secret string

	// CallbackURI is an absolute URI back to which the server will redirect the
	// resource owner when the Resource Owner Authorization step is completed.
	CallbackURI string

	// TemporaryCredentialsURI is an absolute URI used to obtain a set of
	// temporary credentials that can be used to identify the access request
	// throughout the authorization process.
	TemporaryCredentialsURI string

	// AuthorizationURI is an absolute URI used to grant the access request
	// identified by the temporary credentials.
	AuthorizationURI string

	// TokenRequestURI is an absolute URI used to request a set of token
	// credentials using the set of temporary credentials.
	TokenRequestURI string

	// Token contains an end-user's tokens.
	// This may be a set of temporary credentials.
	Token *Token

	// Transport is the HTTP transport to use when making requests.
	// It will default to http.DefaultTransport if nil.
	// It should never be an oauth1.Transport.
	Transport http.RoundTripper
}

var (
	errResponseToken       = errors.New("missing oauth_token")
	errResponseTokenSecret = errors.New("missing oauth_token_secret")
)

// Client returns an *http.Client that makes authenticated requests.
func (t *Transport) Client() *http.Client {
	return &http.Client{Transport: t}
}

// RequestTemporaryCredentials obtains a set of temporary credentials by making
// an authenticated request to the Temporary Credential Request endpoint. The
// AuthorizationURI configured with the required oauth_token query parameter
// is returned if successful.
//
// See RFC 5849 Section 2.1 and 2.2.
func (t *Transport) RequestTemporaryCredentials() (string, error) {
	params := url.Values{"oauth_callback": {t.CallbackURI}}
	_, err := t.request(t.TemporaryCredentialsURI, params)
	if err != nil {
		return "", err
	}

	u, err := url.Parse(t.AuthorizationURI)
	if err != nil {
		return "", err
	}

	q := u.Query()
	q.Set("oauth_token", t.Token.Key)
	u.RawQuery = q.Encode()

	return u.String(), nil
}

// RequestToken obtains a set of token credentials from the server by making an
// authenticated request to the Token Request endpoint.
//
// See RFC 5849 Section 2.3.
func (t *Transport) RequestToken(verifier string) (url.Values, error) {
	params := url.Values{"oauth_verifier": {verifier}}
	return t.request(t.TokenRequestURI, params)
}

// RoundTrip executes a single HTTP transaction using the Transport's Token as
// authorization headers.
//
// See RFC 5849 Section 3.1.
func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {
	// Build the Authorization header.
	header, err := t.authenticate(req, url.Values{})
	if err != nil {
		return nil, err
	}

	// This is so that we don't modify the original request as specified
	// in the documentation for http.RoundTripper.
	req = cloneRequest(req)
	req.Header.Set("Authorization", header)

	// Make the HTTP request.
	return t.transport().RoundTrip(req)
}

// authenticate returns a signed Authorization header for the given request.
//
// See RFC 5849 Section 3.1.
func (t *Transport) authenticate(req *http.Request, params url.Values) (string, error) {
	nonce, err := generateNonce()
	if err != nil {
		return "", err
	}

	// Authenticated requests include several protocol parameters.
	params.Add("oauth_consumer_key", t.Key)
	params.Add("oauth_signature_method", "HMAC-SHA1")
	params.Add("oauth_timestamp", generateTimestamp())
	params.Add("oauth_nonce", nonce)
	params.Add("oauth_version", "1.0")

	// Add the token, if present.
	if t.Token != nil {
		params.Set("oauth_token", t.Token.Key)
	}

	// Build the HMAC key.
	key := encode(t.Secret) + "&"
	if t.Token != nil {
		key += encode(t.Token.Secret)
	}

	// Build the Authorization header.
	header, err := authenticate(req, params, key)
	if err != nil {
		return "", err
	}

	return header, nil
}

// request makes an HTTP POST request to the uri with some extra OAuth
// parameters. The Transport Token is updated from the response.
func (t *Transport) request(uri string, params url.Values) (url.Values, error) {
	c := &http.Client{Transport: t.transport()}
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, err
	}

	header, err := t.authenticate(req, params)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", header)
	response, err := c.Do(req)
	if err != nil {
		return nil, err
	}

	defer response.Body.Close()

	if response.StatusCode != 200 {
		return nil, err
	}

	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		return nil, err
	}

	form, err := url.ParseQuery(string(body))
	if err != nil {
		return nil, err
	}

	key := form.Get("oauth_token")
	if key == "" {
		return nil, errResponseToken
	}

	secret := form.Get("oauth_token_secret")
	if secret == "" {
		return nil, errResponseTokenSecret
	}

	t.Token = &Token{
		Key:    key,
		Secret: secret,
	}

	return form, nil
}

// transport returns the configured Transport, or the http.DefaultTransport.
func (t *Transport) transport() http.RoundTripper {
	if t.Transport != nil {
		return t.Transport
	}

	return http.DefaultTransport
}

// cloneRequest returns a copy of the given request.
func cloneRequest(r *http.Request) *http.Request {
	// shallow copy of the struct
	r2 := new(http.Request)
	*r2 = *r
	// deep copy of the Header
	r2.Header = make(http.Header)
	for k, s := range r.Header {
		r2.Header[k] = s
	}
	return r2
}
